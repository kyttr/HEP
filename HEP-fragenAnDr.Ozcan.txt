- comphep : what does "ZERO:zero contribution" of symbolic calculation mean?
- comphep : after renaming "results" to "results-my", new files do not go to "results-my", but to "results".
- comphep : What is diagram contribution to the squared matrix element?
- comphep : "display distributions" : 1'den fazla "subprocess"i bir arada inceleme
- comphep : "numerical session" : nCall değeri neye göre değiştiriliyor
- comphep : "list of struct. fncs." : PDF:cteq6m(proton) ... bunlar nedir?
- comphep : "model e6" : D-quark (protondaki değil) nedir?
- comphep : "model e6" : neden u-quark'ın kütlesi 0?
- comphep : "model e6" : neden elektronun kütlesi 0?

- comphep : "numerical session" : generateEvents : expected efficieny ne demek?
- results : events_N.txt dosyalarının içeriği ne anlatıyor?

deriving quantum cross-section
classical c-s to quantum
intro2 c-s
phys442 deneyi okuyabilirsin.
LHC'deki total interacton c-s

pythıa kod : olay içindeki kaon+/- bul. Bunların p, pt, eta(pseudo rapidity), phi histogramları çıkar.

histos --> root dosyası, no print
phi histo --> pol0 fit yap.
butun histos --> tree kaydet.

dedektör parçacıkları nasısl değiştiriyor --> delphes --> google and install 

kendi D quarkları üret. bunlar --> pythia. sonra--> delphes
delphes'e 

cpyth : "cross-section"a göre subprocess karıştırma
pp-->Hjzj (Pythia "de","De" parçacıklarını tanımıyor)

p = u,d,U,D,s,c,S,C,G

2.4.2013/Salı
- cpyth   : programını kuramadım. Doğru versiyonu bulamadım.
- pythia  : Delphes bağlantısı için hangi dosyalar üretilmeli,gerekli?
- root    : hemen her şeyi barındıran bir ".root" dosyası üreten kod örneği. Ör:"delphes_output.root", "pgs_events_Q1.root"

! 1) Settings that will be used in a main program.
Main:numberOfEvents = 200          ! number of events to generate
# Bu nokta comment-out gerekebilir.
	--> main42kayasv2.cmnd dosyasında bu satırı "comment-out" ettim.

03.04.2013/Çrş
1.pythia'da yalnızca z->e-e+ ve z->mu-mu+ kanallarını aktifleştir, diğerlerini kapat.
2.Delphes'te hepMC dosyasını ATLAS'tan geçir.
3.".root" dosyası --> MakeClass
	in each "event" : 
	maxPT(e) --> histogram (eta,phi,PT)
	maxPT(mu) --> histogram
	maxPT(jet) --> histogram
	2. maxPT(jet)  (ikinci en çok PT)--> histogram

	--> yukarıdaki 3 adımdan yalnızca 2. yi yaptım.
	~> yukarıdaki 3 adımdan tamamlananlar : 1,2
	~> yukarıdaki 3 adımdan tamamlananlar : 1,2,3


 Erkcan Özcan on 16.04.2013 :  
        1) e+e- ve mu+mu- invariant mass histogramlarini ekleyelim, Z bozonunu gorelim.
        2) Z bozonu ile olaydaki en yuksek pt'li jeti birlestirip invariant mass histogramina bakalim.


- root, delphes : Elektron derken "Electron" dalındaki nesneler mi, yoksa "Particle" dalında olup PID'si 11 olan parçacıklar mı? Aralarındaki fark nedir?
- root, TTree : "e6_rootMacro1.C" ve "e6_rootMacro1vTree.C" dosylarının ürettiği histogramlar farklı oluyor, bu "binning" ile mi ilgili?

17.04.2013/Çrş
1. "Particle" dalında PID=Higgs olan parçacıkları bul. 85<mass<105 olan jetleri bul. Bu Higgs'ler ile jetler arasındaki "deltaR" bul. deltaR=sqrt(deltaEta^2+deltaPhi^2) gibi bir şey.

        de      De 
         |      |
        / \    / \
       H  j    Z  j         bu seviyedeki jetlere "prompt jet" diyeceğiz.
       |
      / \
      j  j

2. Z bozonunu "e-e+" ve "mu-mu+" çiftleri ile yeniden yarat (reconstruct Z boson). (Şu anda yalnızca z->e-e+ ve z->mu-mu+ kanalları aktif.)
3. De'yi "Z bozonu+jet" ikilisi ile yeniden yarat (reconstruct De).
    3.1 jet = PT'si en yüksek olan jet
    3.2 jet = PT'si 2. en yüksek olan jet
        --> EDIT : şu anda her olaydan Z bozonu yaratmıyorum. Bir olayda Higgs yaratabiliyorsam, o zaman o olayda  Z bozonu yaratıyorum.
4. Higgs bozonunu "jet3+jet4" ikilisi ile yeniden yarat (reconstruct Higgs boson).
    jet3 =  PT'si 3. en yüksek olan jet
    jet4 =  PT'si 4. en yüksek olan jet
        --> EDIT : şu anda her olaydan Higgs yaratmıyorum. Bir olayda Z bozonu yaratabiliyorsam, o zaman o olayda Higgs yaratıyorum.
5. de'yi "H+jet" ile De'yi "Z+jet" ile yeniden yarat.
    5.1. H + jet1 --> de ,  Z + jet2 --> De
    5.2. H + jet2 --> de ,  Z + jet1 --> De
        (jet1 = PT'si en yüksek olan jet , jet2 = PT'si 2. en yüksek olan jet)
    deltaMass = abs (de.Mass - De.Mass) hesapla. "deltaMass" minimize eden kombinasyonu bul.

EDIT on 24.04.2013/Çrş :
    "Yeniden yaratılan Z" : kütle 90 GeV civarında tavan yapıyor, pek sorun yok gibi. 
    "Yeniden yaratılan De" : kütle 500 GeV civarında tavan yapıyor, pek sorun yok gibi. 
    "Yeniden yaratılan Higgs" : en fazla görülen kütle 120 GeV, ama bu diğer kütlelerden sıyrılmıyor.
    "Yeniden yaratılan de" : "De" gibi keskin değil
    "deltaMass" : 2 kombinasyon arasında pek bir fark yok, ama "H + jet1 --> de ,  Z + jet2 --> De" kombinasyonu daha uygun sanki.


As far as I understood : reconstruction = particle1.LorentzVector + particle2.LorentzVector

".root" dosyası --> MakeClass , ne demek olduğunu eski dosyalara bakarak hatırladım
    root -l pgs_events_Q1.root
    .ls
    LHCO->MakeClass("exercise1");

ref :
http://root.cern.ch/download/doc/ROOTUsersGuideHTML/ch12s21.html
/pgsROOTexercise-kaya/instructions.txt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//    histMass_Higgs->Draw();  // does not work, generates empty canvas   
//    histMass_Higgs->DrawClone(); // does not work, generates empty canvas
//    histMass_Higgs->DrawCopy(); //works
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

01.05.2013/Çrş
Farklı işler/metotlar için farklı ".root" dosyları oluşturma. Hepsini bir ".root" dosyasında topla.

1. her olayda "deltaMass_of_deDe" yi minimize eden kombinasyon bul. O kombinasyon kullan, histogram çıkart.
2. deltaR( true Z,  85<mass<105 olan jet ). deltaR 0'da yükseliyorsa "bu jetler aslında Z imiş," diyeceğiz. Aslında, "loop_deltaR_HIGGS_and_JET" yerine "loop_deltaR_Z_and_JET" diye bir metot çalışacak.
        --> EDIT :  deltaR(Z,jet) histogramları için 3 farklı duruma bakıyorum.
                1. kütlesi belirli bir aralıkta olan jetler (85<mass<105 gibi)
                2. deltaR(Z,jet) değeri belirli bir limitin altında olan jetler (limit_deltaR = 0.5 gibi)
                3. deltaR(Z,jet) değeri en küçük olan jet (her Z için böyle bir jetten tam 1 tane vardır.)
                
             deltaR(Z,jets with 85<mass<105) değerleri 0'a yaklaşmıyor pek. --> Bu sorun halloldu.
                    -->    double jet_massMin = 85000; // IMPORTANT, for the jet mass unit is MeV
                           double jet_massMax = 105000; // IMPORTANT, for the jets mass unit is MeV
                           
             Yukarıdaki değerleri kullanınca Higgs ile Jet arasındaki deltaR sıfırda yükseldi.
                           
              Eskiden aşağıdaki değerleri kullanıyordum. Bu da 85 GeV'ye değil, 85 MeV'ye denk geliyordu ve istediğimiz sonuçları vermiyordu. Beni yanlışa götüren nokta şu idi : "Particle" setinde kütle birimi GeV, "Jet" setinde ise MeV.
                            //    double jet_massMin = 85;
                            //    double jet_massMax = 105;

3. electron_size=2 olaylarında deltaR(jet, herhangi e)<0.2 olan jetleri analizden çıkar. Çünkü, bu jetler aslında jet değil, elektron. Elektron olmalarına rağmen dedektörde elektron olarak tespit edilmişler. Bu jetlerin analizden çıkarılması bize H,Z,de,De yeniden yaratılmasında yardımcı olabailir. Çünkü, bu jetler jet1 ve jet4 arası bir yerde olabilir.

4. chi^2=(mass(jet3+jet4)-120)^2/30^2+(mass(jet1+3+4)-mass(Z+jet2))^2/30^2
	her olay için bütün chi^2 kombinasyonlarını bul.
 	En küçük chi^2 değeri veren kombinasyonu kullanarak :
		H, Z, de, De yeniden yarat.
		H.Mass histogramı çıkart. Bu histograma Gaussian Fit yap. "Fit" in döndürdüğü "width" değerini chi^2 hesabının paydasındaki 30^2 yerine yaz.
	H.Mass histogramını keskinleştirmek için chi^2 hesabını 1-2 kere döndür. Her döngüde bir önceki "width" değerini kullan. 1. döngü için "width"=30^2 veya "width"=30.

08.05.2013/Çrş

deltaR(jet, Z) with : 85<jet.mass<105, Z as (generated) Particle
	bu deltaR histogramı 0'a çok yakın yerde tavan yapıyor. 
	Ayrıca "Z->e-e+" elektronları önceki Z bozonuna çok yakın bir yönde ilerliyor. Bu durumda 
		deltaR(jet,e) with : e as Electron
			bu deltaR histogramının da 0'a çok yakın çok fazla değeri olması beklenir. Geçen hafta yazdığım notta "electron_size=2 olaylarında deltaR(jet, herhangi e)<0.2 olan jetleri analizden çıkar." demiştim. Ama, hemen hemen hiçbir jet elenmedi. Bu demek ki "deltaR(jet,e) with : e as Electron" değeri 0'a çok yakın olan hemen hiçbir jet yok. Bu durum sorun yaratıyor. ==> Çelişki
==> çözüm önerisi
	- "electron_size=2 olaylarında deltaR(jet, herhangi e)<0.2 olan jetleri analizden çıkar." --> bu işi yapan "filterJets()" metodumda hata olabilir.
	- deltaR(jet,e)<0.2 with : e as Electron 
		sağlayan jet.mass histogram
	- deltaR(jet,e+e-)<0.2 with : e as Electron 
		sağlayan jet.mass histogramı
	- deltaR(e1 as Particle, e2 as Elektron)=minimum. with : e1 as Particle, e2 as Elektron 
		deltaR(e as Particle, e as Elektron) minimum olan deltaR histogramı, elektronları yüklerine göre ayırt et.
	
TH1F nesnesine fit yapmayı biliyorum. "TTree"deki "Branch" nesnelerine nasıl fir yapacağım?
	-->	"bracnh->Draw()" sonucunda dönen histograma fit

çabuk ilerlersek, pythia'da "z+jet" background sample oluştur ve onları Delphes'ten geçir.	
	"z+jet" background sample için "pythia/examples" dizininde "ttbar" içeren örneğe bak.
Sonrasında "pp->deDe" simulasyonu ile "z+jet" background sample birleştireceğiz. Bunu olayların ağırlıklarına ("weight") göre yapacağız.
	
deltaR(jet,e)<0.2 sağlayan jet.mass histogramı
deltaR(jet,e+e-)<0.2 sağlayan jet.mass histogramı ve bu jetleri ele.

bracnh->Draw()	--> dönen histoya fit

deltaR(e as Particle, e as Elektron) minimum olan deltaR(e as Particle, e as Elektron) histogramı, "e" ları yüklere ayır.

çabuk ilerlersek,
pythia'da "z+jet" background sample oluştur ve onları Delphes'ten geçir.

15.05.2013/Çrş

1.
"loop_deltaR_Z_and_JET" --> electron ve muon olan olaylar için ayrı ayrı analiz yap. Bunun için z'nin "daughter" larını kontrol et. Ayrıca deltaR(jet, daughter of Z) histogramla.
        "loop_deltaR_Z_and_JET()" metodunda deltaR(jet,Z) : Z as Particle hesaplanıyor. Yani "Particle" setindeki Z bozonları alınıyor ve bunlar ile olaydaki her jet arasındaki deltaR hesaplanıyordu. Şimdi ise aynı Z bozonlarını 2 gruba ayıracağız.
        1. grup : Z.daughter = e  : Z as Particle  --> çocukları elektron olan Z
        2. grup : Z.daughter = mu : Z as Particle  --> çocukları muon olan Z
            
            --> Her bir "daughter" (çocuk) için deltaR(jet,"daughter" of Z) histogram.
                    ==> histogram deltaR(jet,"daughter" of Z)

2.  
deltaR(jet,Z as Particle)<0.2 olan olaylar için (e+e-).mass histogramla (recoZ.mass : e+e- --> Z , e+/e- as Electron)
        histogram recoZ.mass : e+ e- --> recoZ , e+/e- as Electron , there is a "deltaR(jet,Z as Particle)<0.2" case in the event.
	
3.
pythia : Z+jet üret. Delphes'ten geçir. 
        ==> De.mass=500 peak'i zayıflamalı.

        Delphes'in ürettiği ".root" dosyasında çalışmak için "makeClass" ile ayrıca bir "class" üretmeye gerek yok. "Z+jet background" içeren bu yeni ".root" dosyası aslında bizim "main42hepMC_E6_v4_by_delphes.root" dosyası ile aynı yapıya sahip. Sonuçta "main42hepMC_E6_v4_by_delphes.root" dosyasından "makeClass" ile üretilen "e6_Class" isimli "class" yeni dosya üzerinde de çalışabilir. Bunun için "e6_Class" ın ana metodunda "class"ın hangi dosya ile çalışacağını belirtmek gerek. Dosya belirtilmez ise "e6_Class" varsayılan olarak "main42hepMC_E6_v4_by_delphes.root" dosyasını seçecek. Çalışılacak dosyayı ayrıca belirtmek için:
            
        // bu koddan tam emin değilim.
            int e6_myClass() {
                TFile *f = new TFile("main42hepMC_E6_v4_by_delphes.root");
                TTree *tree = (TTree*) gDirectory->Get("Delphes");
                e6_Class t(tree);
                ...                 
	
Ayrıca, "Z+jet background" içeren bu yeni ".root" dosyasındaki "kMaxSomething" değişkenleri "e6_Class"taki ile aynı değere sahip olmayabilir. Bu durum sorun çıkarabilir.
    Ex : const Int_t kMaxParticle = 3751; // "e6_Class.h", line 21
	
SORUNLAR :
        H.mass=80 : H as Particle      ---(true higgs mass=80)
        jet.mass=90 civarında peak     ---özellikle bu (most !)
	de.mass broad : H + jet --> de, H is reco.       ---de.mass=500'de peak yok, geniş bir dağılım var.


30.05.2013/Çrş

z+jet backgroud :
	main03.cc dosyasına bak.
	1000 event çalıştır --> c-s kontrol
	google --> z+jet c-s at LHC, your c-s must be same order of mag. as LHC result
	

deltaR(jet,Z as Particle)<0.2 olan olaylar için (e+e-).mass histogramla (recoZ.mass : e+e- --> Z , e+/e- as Electron)
    histogram recoZ.mass : e+ e- --> recoZ , e+/e- as Electron , there is a "deltaR(jet,Z as Particle)<0.2" case in
the event.
	EDIT :
	Yukarıdaki işi yaptım. Sonuçlar "loop_deltaR_Z_and_JET.root" dosyasının "RecoZ-with-under-limit-deltaR" isimli TTree'sinde duruyor. Burada dikkat çeken nokta gereken : "deltaR(jet,Z as Particle)<0.5" durumunu sağlayan 1208 jet var. Ama, "deltaR(jet,Z as Particle)<0.5" sağlayan olaylar ile 8 tane Z bozonu yeniden yaratabildim. Bu sayı 1208'e göre çok düşük. ==> Bir olayda hem "deltaR(jet,Z as Particle)<0.5" hem "electron_size=2" sağlanması düşük bir olasılık. Veya, bir olayda "deltaR(jet,Z as Particle)<0.5" sağlayan bir jet var ise o zaman o olayda 2 tane e+/e- (e as Electron) bulmamız düşük bir olasılık.
	
Şu ana kadar neden deltaR(jet,Z as Particle) durumlarını inceledik? Çünkü, "loop_Reconstruct_All*" dosyalarındaki "jet.Mass" histogramlarında 90 GeV civarında bir tepecik var. 90 GeV, Z bozonu kütlesine karşılık geliyor. ==> jet.mass=90 GeV civarı olan jetler aslında Z olabilir. Z bozonunun jet olarak tespit edilmesine neden olabilecek durum olarak şunu önerdik : Z bozonu yüksek momentum ile ilerliyor. Birbirine yakın 2 e+/e- olarak bozunuyor. Bu 2 e+/e- yakın olarak ilerledikleri için dedektörde jet olarak tespit ediliyor. ==> Dedektör, Z'ten çıkan elektronları "e as Electron" olarak değil, jet olarak algılıyor. Böyle bir olayda elimizde "e as Electron" olmadığı için reconstructed Z üretemiyoruz. Üretmemiz gereken reconstructed Z, jet olarak gözüküyor. Bu hipotez, yukarıdaki "EDIT" ile örtüşüyor : "deltaR(jet,Z as Particle)<0.5" sağlanmışsa o olaydaki Z as Particle'dan çıkan 2 e+/e- (as Particle) ve çevresi muhtemelen jet olarak tespit edilmiştir. O zaman elimizdeki 2 e+/e- as Particle, jet olarak göründüğü için e+/e- as Electron olarak yeniden yaratılamadı. ==> "deltaR(jet,Z as Particle)<0.5" sağlanan olayda 2 tane e+/e- (e as Electron) bulmamız düşük bir olasılık, çünkü Z'den çıkan elektronlar (e as Particle) jet olarak göründü.
	
"filterJets()" metodunda şu ana kadar (e as Electron) ile eşleşen jetleri elemeye çalıştım. Yukarıdaki notları gördükten sonra (e as Particle) ile eşleşen jetleri elemek daha mantıklı olacak.

Bir olayda ortalama 2 tane (Z as Particle) var. Bu olmaması gereken bir şey. Muhtemelen bir Z diğer Z'in çocuğu. Analizde çocukları {mu+,mu-} veya {e+,e-} olan Z bozonlarını (Z as Particle) kullan.